package retrieval

import (
	"context"
	"fmt"

	"github.com/filecoin-project/go-address"
	datatransfer "github.com/filecoin-project/go-data-transfer"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/go-state-types/big"
	"github.com/filecoin-project/go-statemachine/fsm"
	"github.com/ipfs/go-cid"
	peer "github.com/libp2p/go-libp2p-peer"
)

func recordReceived(deal *ClientDealState, totalReceived uint64) error {
	deal.TotalReceived = totalReceived
	return nil
}

var paymentChannelCreationStates = []fsm.StateKey{
	DealStatusWaitForAcceptance,
	DealStatusAccepted,
	DealStatusPaymentChannelCreating,
	DealStatusPaymentChannelAllocatingLane,
}

// ClientChart are the events that can happen in a retrieval client
var ClientChart = fsm.Events{
	fsm.Event(ClientEventOpen).
		From(DealStatusNew).ToNoChange(),

	// ProposeDeal handler events
	fsm.Event(ClientEventWriteDealProposalErrored).
		FromAny().To(DealStatusErrored).
		Action(func(deal *ClientDealState, err error) error {
			deal.Message = fmt.Errorf("proposing deal: %w", err).Error()
			return nil
		}),
	fsm.Event(ClientEventDealProposed).
		From(DealStatusNew).To(DealStatusWaitForAcceptance).
		Action(func(deal *ClientDealState, channelID datatransfer.ChannelID) error {
			deal.ChannelID = channelID
			deal.Message = ""
			return nil
		}),

	// Initial deal acceptance events
	fsm.Event(ClientEventDealNotFound).
		From(DealStatusWaitForAcceptance).To(DealStatusDealNotFound).
		Action(func(deal *ClientDealState, message string) error {
			deal.Message = fmt.Sprintf("deal not found: %s", message)
			return nil
		}),
	fsm.Event(ClientEventDealAccepted).
		From(DealStatusWaitForAcceptance).To(DealStatusAccepted),
	fsm.Event(ClientEventUnknownResponseReceived).
		FromAny().To(DealStatusFailing).
		Action(func(deal *ClientDealState, status DealStatus) error {
			deal.Message = fmt.Sprintf("Unexpected deal response status: %s", DealStatuses[status])
			return nil
		}),

	// Payment channel setup
	fsm.Event(ClientEventPaymentChannelErrored).
		FromMany(DealStatusAccepted, DealStatusPaymentChannelCreating, DealStatusPaymentChannelAddingFunds).To(DealStatusFailing).
		Action(func(deal *ClientDealState, err error) error {
			deal.Message = fmt.Errorf("error from payment channel: %w", err).Error()
			return nil
		}),
	fsm.Event(ClientEventPaymentChannelCreateInitiated).
		From(DealStatusAccepted).To(DealStatusPaymentChannelCreating).
		Action(func(deal *ClientDealState, msgCID cid.Cid) error {
			deal.WaitMsgCID = &msgCID
			return nil
		}),
	fsm.Event(ClientEventPaymentChannelAddingFunds).
		FromMany(DealStatusAccepted).To(DealStatusPaymentChannelAllocatingLane).
		FromMany(DealStatusCheckFunds).To(DealStatusPaymentChannelAddingFunds).
		Action(func(deal *ClientDealState, msgCID cid.Cid, payCh address.Address) error {
			deal.WaitMsgCID = &msgCID
			if deal.PaymentInfo == nil {
				deal.PaymentInfo = &PaymentInfo{
					PayCh: payCh,
				}
			}
			return nil
		}),
	fsm.Event(ClientEventPaymentChannelReady).
		From(DealStatusPaymentChannelCreating).To(DealStatusPaymentChannelAllocatingLane).
		From(DealStatusPaymentChannelAddingFunds).To(DealStatusOngoing).
		From(DealStatusCheckFunds).To(DealStatusOngoing).
		Action(func(deal *ClientDealState, payCh address.Address) error {
			if deal.PaymentInfo == nil {
				deal.PaymentInfo = &PaymentInfo{
					PayCh: payCh,
				}
			}
			deal.WaitMsgCID = nil
			// remove any insufficient funds message
			deal.Message = ""
			return nil
		}),
	fsm.Event(ClientEventAllocateLaneErrored).
		FromMany(DealStatusPaymentChannelAllocatingLane).
		To(DealStatusFailing).
		Action(func(deal *ClientDealState, err error) error {
			deal.Message = fmt.Errorf("allocating payment lane: %w", err).Error()
			return nil
		}),

	fsm.Event(ClientEventLaneAllocated).
		From(DealStatusPaymentChannelAllocatingLane).To(DealStatusOngoing).
		Action(func(deal *ClientDealState, lane uint64) error {
			deal.PaymentInfo.Lane = lane
			return nil
		}),

	// Transfer Channel Errors
	fsm.Event(ClientEventDataTransferError).
		FromAny().To(DealStatusErrored).
		Action(func(deal *ClientDealState, err error) error {
			deal.Message = fmt.Sprintf("error generated by data transfer: %s", err.Error())
			return nil
		}),

	// Receiving requests for payment
	fsm.Event(ClientEventLastPaymentRequested).
		FromMany(
			DealStatusOngoing,
			DealStatusFundsNeededLastPayment,
			DealStatusFundsNeeded).To(DealStatusFundsNeededLastPayment).
		From(DealStatusBlocksComplete).To(DealStatusSendFundsLastPayment).
		FromMany(
			paymentChannelCreationStates...).ToJustRecord().
		Action(func(deal *ClientDealState, paymentOwed abi.TokenAmount) error {
			deal.PaymentRequested = big.Add(deal.PaymentRequested, paymentOwed)
			deal.LastPaymentRequested = true
			return nil
		}),
	fsm.Event(ClientEventPaymentRequested).
		FromMany(
			DealStatusOngoing,
			DealStatusBlocksComplete,
			DealStatusFundsNeeded).To(DealStatusFundsNeeded).
		FromMany(
			paymentChannelCreationStates...).ToJustRecord().
		Action(func(deal *ClientDealState, paymentOwed abi.TokenAmount) error {
			deal.PaymentRequested = big.Add(deal.PaymentRequested, paymentOwed)
			return nil
		}),

	fsm.Event(ClientEventUnsealPaymentRequested).
		From(DealStatusWaitForAcceptance).To(DealStatusAccepted).
		Action(func(deal *ClientDealState, paymentOwed abi.TokenAmount) error {
			deal.PaymentRequested = big.Add(deal.PaymentRequested, paymentOwed)
			return nil
		}),

	// Receiving data
	fsm.Event(ClientEventAllBlocksReceived).
		FromMany(
			DealStatusOngoing,
			DealStatusBlocksComplete,
		).To(DealStatusBlocksComplete).
		FromMany(paymentChannelCreationStates...).ToJustRecord().
		FromMany(DealStatusSendFunds, DealStatusFundsNeeded).ToJustRecord().
		From(DealStatusFundsNeededLastPayment).To(DealStatusSendFundsLastPayment).
		Action(func(deal *ClientDealState) error {
			deal.AllBlocksReceived = true
			return nil
		}),
	fsm.Event(ClientEventBlocksReceived).
		FromMany(DealStatusOngoing,
			DealStatusFundsNeeded,
			DealStatusFundsNeededLastPayment).ToNoChange().
		FromMany(paymentChannelCreationStates...).ToJustRecord().
		Action(recordReceived),

	fsm.Event(ClientEventSendFunds).
		From(DealStatusFundsNeeded).To(DealStatusSendFunds).
		From(DealStatusFundsNeededLastPayment).To(DealStatusSendFundsLastPayment),

	// Sending Payments
	fsm.Event(ClientEventFundsExpended).
		FromMany(DealStatusCheckFunds).To(DealStatusInsufficientFunds).
		Action(func(deal *ClientDealState, shortfall abi.TokenAmount) error {
			deal.Message = fmt.Sprintf("not enough current or pending funds in payment channel, shortfall of %s", shortfall.String())
			return nil
		}),
	fsm.Event(ClientEventBadPaymentRequested).
		FromMany(DealStatusSendFunds, DealStatusSendFundsLastPayment).To(DealStatusFailing).
		Action(func(deal *ClientDealState, message string) error {
			deal.Message = message
			return nil
		}),
	fsm.Event(ClientEventCreateVoucherFailed).
		FromMany(DealStatusSendFunds, DealStatusSendFundsLastPayment).To(DealStatusFailing).
		Action(func(deal *ClientDealState, err error) error {
			deal.Message = fmt.Errorf("creating payment voucher: %w", err).Error()
			return nil
		}),
	fsm.Event(ClientEventVoucherShortfall).
		FromMany(DealStatusSendFunds, DealStatusSendFundsLastPayment).To(DealStatusCheckFunds).
		Action(func(deal *ClientDealState, shortfall abi.TokenAmount) error {
			return nil
		}),

	fsm.Event(ClientEventWriteDealPaymentErrored).
		FromAny().To(DealStatusErrored).
		Action(func(deal *ClientDealState, err error) error {
			deal.Message = fmt.Errorf("writing deal payment: %w", err).Error()
			return nil
		}),
	fsm.Event(ClientEventPaymentSent).
		From(DealStatusSendFunds).To(DealStatusOngoing).
		From(DealStatusSendFundsLastPayment).To(DealStatusFinalizing).
		Action(func(deal *ClientDealState) error {
			// paymentRequested = 0
			// fundsSpent = fundsSpent + paymentRequested
			// if paymentRequested / pricePerByte >= currentInterval
			// currentInterval = currentInterval + proposal.intervalIncrease
			// bytesPaidFor = bytesPaidFor + (paymentRequested / pricePerByte)
			deal.FundsSpent = big.Add(deal.FundsSpent, deal.PaymentRequested)

			paymentForUnsealing := big.Min(deal.PaymentRequested, big.Sub(deal.UnsealPrice, deal.UnsealFundsPaid))

			bytesPaidFor := big.Div(big.Sub(deal.PaymentRequested, paymentForUnsealing), deal.PricePerByte).Uint64()
			if bytesPaidFor >= deal.CurrentInterval {
				deal.CurrentInterval += deal.DealProposal.PaymentIntervalIncrease
			}
			deal.BytesPaidFor += bytesPaidFor
			deal.UnsealFundsPaid = big.Add(deal.UnsealFundsPaid, paymentForUnsealing)
			deal.PaymentRequested = abi.NewTokenAmount(0)
			return nil
		}),

	// completing deals
	fsm.Event(ClientEventComplete).
		From(DealStatusOngoing).To(DealStatusCheckComplete).
		From(DealStatusFinalizing).To(DealStatusCompleted),
	fsm.Event(ClientEventCompleteVerified).
		From(DealStatusCheckComplete).To(DealStatusCompleted),
	fsm.Event(ClientEventEarlyTermination).
		From(DealStatusCheckComplete).To(DealStatusErrored).
		Action(func(deal *ClientDealState) error {
			deal.Message = "Provider sent complete status without sending all data"
			return nil
		}),

	// after cancelling a deal is complete
	fsm.Event(ClientEventCancelComplete).
		From(DealStatusFailing).To(DealStatusErrored).
		From(DealStatusCancelling).To(DealStatusCancelled),

	// receiving a cancel indicating most likely that the provider experienced something wrong on their
	// end, unless we are already failing or cancelling
	fsm.Event(ClientEventProviderCancelled).
		From(DealStatusFailing).ToJustRecord().
		From(DealStatusCancelling).ToJustRecord().
		FromAny().To(DealStatusCancelling).Action(
		func(deal *ClientDealState) error {
			if deal.Status != DealStatusFailing && deal.Status != DealStatusCancelling {
				deal.Message = "Provider cancelled retrieval"
			}
			return nil
		},
	),

	// user manually cancels retrieval
	fsm.Event(ClientEventCancel).FromAny().To(DealStatusCancelling).Action(func(deal *ClientDealState) error {
		deal.Message = "Client cancelled retrieval"
		return nil
	}),

	// payment channel receives more money, we believe there may be reason to recheck the funds for this channel
	fsm.Event(ClientEventRecheckFunds).From(DealStatusInsufficientFunds).To(DealStatusCheckFunds),
}

// ClientFinalityStates are terminal states after which no further events are received
var ClientFinalityStates = []fsm.StateKey{
	DealStatusErrored,
	DealStatusCompleted,
	DealStatusCancelled,
	DealStatusRejected,
	DealStatusDealNotFound,
}

// ClientStateEntryFuncs are the handlers for different states in a retrieval client
var ClientStateEntryFuncs = fsm.StateEntryFuncs{
	DealStatusNew: ProposeDeal,
	// 	rm.DealStatusAccepted:                     SetupPaymentChannelStart,
	// 	rm.DealStatusPaymentChannelCreating:       WaitPaymentChannelReady,
	// 	rm.DealStatusPaymentChannelAllocatingLane: AllocateLane,
	// 	rm.DealStatusOngoing:                      Ongoing,
	// 	rm.DealStatusFundsNeeded:                  ProcessPaymentRequested,
	// 	rm.DealStatusFundsNeededLastPayment:       ProcessPaymentRequested,
	// 	rm.DealStatusSendFunds:                    SendFunds,
	// 	rm.DealStatusSendFundsLastPayment:         SendFunds,
	// 	rm.DealStatusCheckFunds:                   CheckFunds,
	// 	rm.DealStatusPaymentChannelAddingFunds:    WaitPaymentChannelReady,
	// 	rm.DealStatusFailing:                      CancelDeal,
	// 	rm.DealStatusCancelling:                   CancelDeal,
	// 	rm.DealStatusCheckComplete:                CheckComplete,
}

// ClientDealEnvironment is a bridge to the environment a client deal is executing in.
// It provides access to relevant functionality on the retrieval client
type ClientDealEnvironment interface {
	OpenDataTransfer(ctx context.Context, to peer.ID, proposal *DealProposal) (datatransfer.ChannelID, error)
	SendDataTransferVoucher(context.Context, datatransfer.ChannelID, *DealPayment, bool) error
	CloseDataTransfer(context.Context, datatransfer.ChannelID) error
}

// ProposeDeal sends the proposal to the other party
func ProposeDeal(ctx fsm.Context, environment ClientDealEnvironment, deal ClientDealState) error {
	channelID, err := environment.OpenDataTransfer(ctx.Context(), deal.Sender, &deal.DealProposal)
	if err != nil {
		return ctx.Trigger(ClientEventWriteDealProposalErrored, err)
	}
	return ctx.Trigger(ClientEventDealProposed, channelID)
}
